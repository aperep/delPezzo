
# Generated by CodiumAI

import pytest

"""
Code Analysis

Main functionalities:
The CylinderCollection class represents a collection of Cylinder objects, which are collections of curves on a surface. The main functionalities of this class are to compute the complement curves and double points of the collection, to check if the collection is polar on a given cone, to reduce the collection by removing cylinders that overlap with each other, and to make the collection polar on a given cone by selecting the cylinders that are polar on it.

Methods:
- __init__(self, cylinders:list[Cylinder]) -> None: initializes a CylinderCollection object with a list of Cylinder objects
- __add__(self, other): adds two CylinderCollection objects together
- is_polar_on(self, cone): checks if the collection is polar on a given cone
- make_polar_on(self, cone): selects the cylinders that are polar on a given cone and returns a new CylinderCollection object with only those cylinders
- reduce(self, keep_double_points:bool=False) -> 'CylinderCollection': reduces the collection by removing cylinders that overlap with each other
- cached_property methods: fiber, complement_curves, complement_double_points, Pol, Forb: compute and cache the corresponding properties of the collection

Fields:
- S: the surface on which the cylinders are defined
- cylinders: the list of Cylinder objects in the collection
"""



class TestCylinderCollection:

    # Tests that a cylindercollection object can be initialized with a non-empty list of cylinder objects. tags: [happy path]
    def test_init_non_empty(self):
        S = Surface(_sage_const_4 )
        c1 = Cylinder(S, [], Curve(S, [1,0,0]))
        c2 = Cylinder(S, [], Curve(S, [0,1,0]))
        collection = CylinderCollection([c1, c2])
        assert collection.S == S
        assert len(collection.cylinders) == _sage_const_2 
        assert collection.cylinders[_sage_const_0 ] == c1
        assert collection.cylinders[_sage_const_1 ] == c2

    # Tests that a valueerror is raised when a cylindercollection object is initialized with an empty list of cylinder objects. tags: [edge case]
    def test_init_empty(self):
        S = Surface(_sage_const_4 )
        with pytest.raises(ValueError):
            collection = CylinderCollection([])

    # Tests that a valueerror is raised when adding two cylindercollection objects with different surfaces. tags: [edge case]
    def test_add_different_surfaces(self):
        S1 = Surface(_sage_const_4 )
        S2 = Surface(_sage_const_5 )
        c1 = Cylinder(S1, [], Curve(S1, [1,0,0]))
        c2 = Cylinder(S2, [], Curve(S2, [0,1,0]))
        collection1 = CylinderCollection([c1])
        collection2 = CylinderCollection([c2])
        with pytest.raises(ValueError):
            collection1 + collection2

    # Tests that the complement curves property is correctly computed for a cylindercollection object. tags: [happy path]
    def test_complement_curves(self):
        # Happy path test
        S = Surface(_sage_const_4 )
        c1 = Cylinder(S, [Curve([_sage_const_1 ,_sage_const_2 ,_sage_const_3 ]), Curve([_sage_const_2 ,_sage_const_3 ,_sage_const_4 ])])
        c2 = Cylinder(S, [Curve([_sage_const_1 ,_sage_const_2 ,_sage_const_3 ]), Curve([_sage_const_3 ,_sage_const_4 ,_sage_const_5 ])])
        cc = CylinderCollection([c1, c2])
        assert cc.complement_curves == [Curve([1, 2, 3])]

    # Tests that a cylindercollection object can be reduced by removing cylinders that overlap with each other. tags: [happy path]
    def test_reduce(self):
        # Happy path test
        S = Surface(_sage_const_4 )
        c1 = Cylinder(S, [Curve([_sage_const_1 ,_sage_const_2 ,_sage_const_3 ]), Curve([_sage_const_2 ,_sage_const_3 ,_sage_const_4 ])])
        c2 = Cylinder(S, [Curve([_sage_const_3 ,_sage_const_4 ,_sage_const_5 ]), Curve([_sage_const_4 ,_sage_const_5 ,_sage_const_6 ])])
        c3 = Cylinder(S, [Curve([_sage_const_1 ,_sage_const_2 ,_sage_const_3 ]), Curve([_sage_const_4 ,_sage_const_5 ,_sage_const_6 ])])
        cc = CylinderCollection([c1, c2, c3])
        reduced_cc = cc.reduce()
        assert len(reduced_cc.cylinders) == _sage_const_1 
        assert reduced_cc.cylinders[_sage_const_0 ] == c1

    # Tests that a cylindercollection object can correctly determine if it is polar on a given cone. tags: [happy path]
    def test_is_polar_on(self):
        # Happy path test
        S = Surface(_sage_const_4 )
        c1 = Cylinder(S, [Curve([_sage_const_1 ,_sage_const_2 ,_sage_const_3 ]), Curve([_sage_const_2 ,_sage_const_3 ,_sage_const_4 ])])
        c2 = Cylinder(S, [Curve([_sage_const_3 ,_sage_const_4 ,_sage_const_5 ]), Curve([_sage_const_4 ,_sage_const_5 ,_sage_const_6 ])])
        cc = CylinderCollection([c1, c2])
        cone = Cone([Ray([_sage_const_1 , _sage_const_0 , _sage_const_0 ]), Ray([-_sage_const_1 , _sage_const_0 , _sage_const_0 ])])
        assert cc.is_polar_on(cone) == True