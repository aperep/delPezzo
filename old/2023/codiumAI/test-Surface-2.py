
# Generated by CodiumAI

import pytest

"""
Code Analysis

Main functionalities:
The Surface class represents a toric surface and provides methods to compute its properties, such as its minus one curves, double and triple intersections, and cones associated to them. It also provides methods to construct collections of cylinders on the surface, which are used to study its birational geometry.

Methods:
- dot(a,b): computes the intersection number of two curves a and b on the surface
- gram_matrix(rays): computes the Gram matrix of a set of rays in the toric lattice
- Line(exceptional_curves): computes the line bundle associated to a set of exceptional curves
- curves_not_meeting(curves_to_filter, test_curves): filters a list of curves to keep only those that do not intersect a given set of test curves
- independent_sets(curves, size=None): generates all independent sets of curves of a given size, or all sizes if size is not specified
- cylinders(E, constructions): generates a collection of cylinders on the surface, given a set of exceptional curves and a list of construction methods
- all_cylinders(constructions): generates all collections of cylinders on the surface, using all possible sets of exceptional curves

Fields:
- degree: the degree of the surface
- N: the toric lattice of the surface
- K: the canonical divisor of the surface
- E: the exceptional curves of a blowdown to P2
- L: the line bundle associated to the exceptional curves
- minus_one_curves: the set of (-1)-curves on the surface
- double_intersections: the set of double intersections of (-1)-curves on the surface
- triple_intersections: the set of possible triple intersections of (-1)-curves on the surface
- NE: the cone generated by the (-1)-curves on the surface
- Ample: the ample cone of the surface
"""



class TestSurface:

    # Tests that a surface object can be created with a valid degree. tags: [happy path, edge case]
    def test_surface_creation(self):
        # Happy path test
        S = Surface(_sage_const_4)
        assert S.degree == _sage_const_4

        # Edge case test
        try:
            S = Surface(_sage_const_0)
        except ValueError:
            pass
        else:
            assert False, "Expected ValueError for degree 0"

    # Tests that a collection of cylinders can be generated on a surface object using one or more construction methods. tags: [happy path]
    def test_cylinder_generation(self):
        # Happy path test
        S = Surface(_sage_const_4)
        cylinders = list(S.all_cylinders(['lines', 'tangent']))
        assert len(cylinders) > _sage_const_0

    # Tests that all independent sets of curves of a given size can be generated on a surface object. tags: [happy path]
    def test_independent_sets(self):
        # Happy path test
        S = Surface(_sage_const_4)
        independent_sets = list(S.independent_sets(S.minus_one_curves, size=_sage_const_2))
        assert len(independent_sets) > _sage_const_0

    # Tests that a collection of cylinders can be reduced by deleting those that intersect each other. tags: [behavior, edge case]
    def test_reduce_cylinders(self):
        # Test that a collection of cylinders can be reduced by deleting those that intersect each other
        S = Surface(_sage_const_4 )
        E = S.minus_one_curves
        c1 = Cylinder(S, [E[_sage_const_0 ], E[_sage_const_1 ]])
        c2 = Cylinder(S, [E[_sage_const_1 ], E[_sage_const_2 ]])
        c3 = Cylinder(S, [E[_sage_const_2 ], E[_sage_const_3 ]])
        c4 = Cylinder(S, [E[_sage_const_3 ], E[_sage_const_4 ]])
        c5 = Cylinder(S, [E[_sage_const_4 ], E[_sage_const_5 ]])
        c6 = Cylinder(S, [E[_sage_const_5 ], E[_sage_const_6 ]])
        collection = CylinderCollection([c1, c2, c3, c4, c5, c6])
        reduced_collection = collection.reduce()
        assert len(reduced_collection.cylinders) == _sage_const_1 
        assert reduced_collection.cylinders[_sage_const_0 ] == c1

    # Tests that the intersection number of two curves on a surface object can be computed. tags: [behavior]
    def test_intersection_number(self):
        # Test that the intersection number of two curves on a surface object can be computed
        S = Surface(_sage_const_4 )
        E = S.minus_one_curves
        assert S.dot(E[_sage_const_0 ], E[_sage_const_1 ]) == _sage_const_0 
        assert S.dot(E[_sage_const_0 ], E[_sage_const_2 ]) == -_sage_const_1

    # Tests that the gram matrix of a set of rays in the toric lattice of a surface object can be computed. tags: [behavior]
    def test_gram_matrix(self):
        # Test that the Gram matrix of a set of rays in the toric lattice of a surface object can be computed
        S = Surface(_sage_const_4 )
        rays = [S.N([_sage_const_1 , _sage_const_0 , _sage_const_0 ]), S.N([_sage_const_0 , _sage_const_1 , _sage_const_0 ]), S.N([_sage_const_0 , _sage_const_0 , _sage_const_1 ])]
        gram = S.gram_matrix(rays)
        assert gram[_sage_const_0 ][_sage_const_0 ] == _sage_const_1 
        assert gram[_sage_const_1 ][_sage_const_1 ] == _sage_const_1 
        assert gram[_sage_const_2 ][_sage_const_2 ] == _sage_const_1 
        assert gram[_sage_const_0 ][_sage_const_1 ] == _sage_const_0 
        assert gram[_sage_const_1 ][_sage_const_0 ] == _sage_const_0 
        assert gram[_sage_const_0 ][_sage_const_2 ] == _sage_const_0 
        assert gram[_sage_const_2 ][_sage_const_0 ] == _sage_const_0 
        assert gram[_sage_const_1 ][_sage_const_2 ] == _sage_const_0 
        assert gram[_sage_const_2 ][_sage_const_1 ] == _sage_const_0